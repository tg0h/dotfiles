#!bin/zsh

function ud(){
  # fzf preview and switch to folder
  # ud configure - show configuration
  # ud configure edit - edit configuration
  # examples:
  # ud <searchDir> <searchDepth)
  # eg ud ~/.local/bin 2
  # TODO: how to implement priority with most frequently used first?
  local configFile=$XDG_CONFIG_HOME/tg/dir-switcher/config.yml

  if [[ $1 == "configure" ]] && [[ $2 == "list" ]]; then
    udConfigureList $configFile
    return
  fi

  # prefer nvim over eu for clarity and unneeded dependency on eu alias
  [[ $1 == "configure" ]] && [[ $2 == "edit" ]] && nvim $configFile && return

  local changeToDir
  local searchDir=${1:-$XDG_CONFIG_HOME} # var expansion with default - get the $1 arg, if not found, default to $XDG_CONFIG_HOME
  local searchDepth=${2:-1}
  local glob=${3:-.} # default to . if not provided
  local showHidden=${4:+"--hidden"} # if non-null, change to --hidden
  local showIgnore=${5:+"--no-ignore"}
  local xargs=${6}
  local previewGitIgnore=${7:-"--git-ignore"}
  # fd --follow - follow symlink
  # TODO: exa does not show the contents for the symlink if you do not specify a trailing /
  local xargsCmd
  if [[ -n "$xargs" ]]; then
    xargsCmd="| xargs $xargs"
  fi

  # one shot filter, not used again when reloading command with ctrl-r or crtl-h
  # note the difficulty of passing a glob of \.git$ to fd
  # the string \\.git$ is stored in yml
  # it is converted to json
  # from json we pass it as a string to the $glob option
  # we eval $glob
  # if we eval \.git$ directly, the \. is interpreted as a shell escape
  # therefore, we must surround the glob with single quotes to prevent shell escaping
  local searchCmd="fd '$glob' $searchDir $showHidden $showIgnore --follow --color always --max-depth $searchDepth $xargsCmd"

  
  local out=$(eval $searchCmd | fzf +m --preview='[[ $(file --mime {}) =~ inode/directory ]] &&
    exa '$previewGitIgnore' --tree --long --icons --git --color always --sort modified --reverse --level '$searchDepth' --no-permissions --no-user --changed {}/ || (bat --style=numbers --color=always {} || cat {}) 2> /dev/null | head -300' \
    --bind 'ctrl-t:reload(fd . '$searchDir' --type d --follow --color always --max-depth '$searchDepth')+change-prompt(dir>)' \
    --bind 'ctrl-s:reload(fd . '$searchDir' --type f --follow --color always --max-depth '$searchDepth')+change-prompt(file>)' \
    --bind 'ctrl-h:reload(fd . '$searchDir' --follow --color always --max-depth '$searchDepth')+change-prompt(>)' \
    --multi \
    --expect=alt-d
  )

  local target
  local key=$(head -1 <<< "$out")
  local targets=$(tail -n +2 <<< "$out") # get all lines after the first line
  local target1=$(head -1 <<< "$targets")

  if [ "$key" = alt-d ]; then
    # if dir, switch
    [[ -d $target1 ]] && cd $target1 && return

    # if file, switch to directory of file
    [[ -f $target1 ]] && target=${target1%/*} # zsh variable expansion - min match pattern /* and remove from tail
    cd $target && return
  fi
  # change to directory if it is not null, needed if fzf does not return a dir, eg
  # if fzf cancels via ctrl c

  if [[ -n "$target1" ]]; then
    [[ -d "$target1" ]] && cd $target1 && return
    # if target is a file (check with -f), change to its dir instead
    # [[ -f $target ]] && target=${target%/*} # zsh variable expansion - min match pattern /* and remove from tail
    if [[ -f "$target1" ]]; then
      # TODO: does not work if path has spaces
      targets=$(join-lines <<< "$targets")
      nvim ${=targets}
    fi
  fi
}
