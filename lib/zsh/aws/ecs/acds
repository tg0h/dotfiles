#!/bin/zsh

function acds(){
  # aws ecs describe services
  # default to staging cluster
  # -c d|s|p # to get dev, staging or prod cluster
  # -n # number of events to display for the service
  # -p # show 1 piece of data per line

  local verbose cluster clusterOpt service number plain
  while getopts 'vc:n:pd' opt; do
    case "$opt" in
      v) verbose=true;;
      d) debug=true;;
      n) number=$OPTARG;;
      p) plain=true;;
      c) clusterOpt=$OPTARG
        case "$clusterOpt" in
          d) cluster="DeveloperCluster";;
          s) cluster="StagingCluster";;
          p) cluster="ProductionCluster";;
        esac
        ;;
    esac
  done
  shift $(($OPTIND - 1))

  number=${number:-20}
  cluster=${cluster:-StagingCluster}
  service=${@:-DaemonV2Service}
  [ -n "$debug" ] && echo number is $number >&2

  # service.status can be
  #   ACTIVE
  #   DRAINING
  #   INACTIVE
  # deployment.status can be 
  #   PRIMARY  - most recent deployment
  #   ACTIVE   - still has running tasks, being replaced by PRIMARY
  #   INACTIVE - deployment has been completely replaced
  # deployment.rolloutState can be 
  #   IN_PROGRESS
  #   COMPLETED

    local jqQuery=$(cat <<-EOF
   include "pad";
   include "colour";
   include "aws-time";
   include "aws-ecs";
   def placementStrategy:
     map("\(.type | lp(10) | _y(.)):\(.field)")[];
   def pTaskDefinition:
     gsub(".*/(?<x>.*)";_orange((.x)));
   def service:
     "\(.serviceName| _brinkPink(.)) \(.taskDefinition | pTaskDefinition) ðŸŽ¯\(.desiredCount) \(.runningCount|tostring|_g(.)) \(.pendingCount|tostring|_y(.)) \(.status | _serviceStatus) \(.deploymentConfiguration.minimumHealthyPercent)% \(.deploymentConfiguration.maximumPercent)%",
     "\(.placementStrategy|placementStrategy)"
  ;
   def deployment:
     # "\(.taskDefinition | __(.))"+"\n"+
     "\(.status | _deploymentStatus) ðŸŽ¯\(.desiredCount) \(.runningCount|tostring|_g(.)) \(.pendingCount|tostring|_y(.)) \(.failedTasks|tostring|_r(.)) ðŸš‚ \(.createdAt | pTime) ðŸš€ \(.updatedAt | pTime) \(.rolloutState | _rolloutState) \(.rolloutStateReason)"
   ;
   def _completed:
     sub("(?<dc>deployment completed)"; _nb((.dc)));
   def _brackets:
     gsub("(?<openb>\\\\()(?<br>.*?)(?<closeb>(\\\\)))"; __(.openb)+__((.br))+__(.closeb) );
   def _stopped:
     gsub("(?<x>stopped)"; _r((.x)));
   def _started:
     gsub("(?<x>started)"; _y((.x)));
   def _reached:
     gsub("(?<x>reached a steady state)"; _g((.x)));
   def _filler:
     gsub("(?<x>(has|\\\\.|:))"; __((.x)));
   def _unable_to_place_a_task:
     gsub("(?<x>unable to place a task)"; _brinkPink((.x)));
   def _unhealthy:
     gsub("(?<x>unhealthy)"; _brinkPink((.x)));
   def registered:
     gsub("(?<x> registered)"; _by((.x)));
   def _colourFilter:
     _completed | _filler | _started | _stopped | _reached | _brackets | _unable_to_place_a_task | _unhealthy ;
   def event:
     "  \(.createdAt | pTime) \(.message | _colourFilter)";

   .services[] | 
   service, 
   "\(.deployments | map(deployment)[])",
   "\(.events[0:$number] | map(event)[])"
EOF
)

    local jqQueryPlain=$(cat <<-EOF
   include "pad";
   include "colour";
   include "aws-time";
   def pTaskDefinition:
     gsub(".*/(?<x>.*)";_orange((.x)));
   def deployment:
     "ðŸŽ¯\(.desiredCount|lp(3))ðŸŸ¢\(.runningCount|lp(3))ðŸŸ¡\(.pendingCount)ðŸ”´\(.failedTasks) \(.status) ðŸš‚\(.createdAt | pTime) ðŸš€\(.updatedAt | pTime) \(.rolloutState) ";
   def service:
     "\(.serviceName| rp(40) | _brinkPink(.)) ðŸŽ¯\(.desiredCount|lp(3))ðŸŸ¢\(.runningCount|lp(3))ðŸŸ¡\(.pendingCount|lp(3)) \(.status) \(.deployments | map(deployment)[])";
   .services[] | service
EOF
)


  # ${=var} - tell zsh to word split var
  local result=$(aws ecs describe-services --cluster $cluster --service ${=service})

  [ -n "$debug" ] && echo jqQuery is $jqQuery >&2

  if [ -n "$verbose" ]; then
    jq --raw-output -L "~/.config/jq" "." <<< $result
  elif [ -n "$plain" ]; then
    jq --raw-output -L "~/.config/jq" "$jqQueryPlain" <<< $result
  else
    jq --raw-output -L "~/.config/jq" "$jqQuery" <<< $result
  fi
}
